// SPDX-License-Identifier: MIT
pragma solidity >=0.5.16 <0.9.0;


contract SupplyChain {

    address contractOwner;
    uint  upc;
    uint  sku;

    mapping(uint => Item) items; // (upc => Item)

    // Define a public mapping 'itemsHistory' that maps the UPC to an array of TxHash,
    // that track its journey through the supply chain -- to be sent from DApp.
    mapping(uint => string[]) itemsHistory; // (upc => [progress?])

    enum State
    {
        ForSale, // 0
        Sold, // 1
        Shipped, // 2
        Received // 3
    }

    State constant defaultState = State.ForSale;

    struct Item {
        uint sku;  // Stock Keeping Unit (SKU)
        uint upc; // Universal Product Code (UPC), generated by the Farmer, goes on the package, can be verified by the Consumer
        address ownerID;  // Metamask-Ethereum address of the current owner as the product moves through 8 stages
        uint productID;  // Product ID potentially a combination of upc + sku
        string productNotes; // Product Notes
        uint productPrice; // Product Price
        State itemState;  // Product State as represented in the enum above
        address consumerID; // Metamask-Ethereum address of the Consumer
    }

    event ForSale(uint upc);
    event Sold(uint upc);
    event Shipped(uint upc);
    event Received(uint upc);


    /* Modifiers ************************ */

    modifier onlyOwner() {
        require(msg.sender == contractOwner, "Only the owner can perform this operation");
        _;
    }

    modifier verifyCaller (address _address) {
        require(msg.sender == _address);
        _;
    }

    modifier paidEnough(uint _price) {
        require(msg.value >= _price, "Not enough was paid for the item");
        _;
    }

    modifier checkValue(uint _upc) {
        _;
        uint _price = items[_upc].productPrice;
        uint amountToReturn = msg.value - _price;

    }


    modifier forSale(uint _upc) {
        require(items[_upc].itemState == State.ForSale, "The item is not yet for sale");
        _;
    }

    modifier sold(uint _upc) {
        require(items[_upc].itemState == State.Sold, "The item is not yet sold");
        _;
    }

    modifier shipped(uint _upc) {
        require(items[_upc].itemState == State.Shipped, "The item is not yet shipped");
        _;
    }

    modifier received(uint _upc) {
        require(items[_upc].itemState == State.Received, "The item is not yet received");
        _;
    }


    /* Constructor & utils ************************ */

    constructor() public payable {
        contractOwner = msg.sender;
        sku = 1;
        upc = 1;
    }

    

    /* Functions ************************ */

    function buyItem(
        uint _upc,
         address _ownerID,
        string memory _productNotes) public onlyOwner
    {
        items[_upc] = Item({
            sku: sku,
            upc: _upc,
            ownerID: contractOwner,
            productID: _upc + sku,
            productNotes: _productNotes,
            productPrice: uint(0),
            itemState: defaultState,
             consumerID: address(0)
            });

        sku = sku + 1;

        emit ForSale(_upc);
    }

    function buyItem(uint _upc) public payable forSale(_upc) paidEnough(items[_upc].productPrice)
    {
        items[_upc].ownerID = contractOwner;
        items[_upc].itemState = State.Sold;
        
    }

    function fetchItemBufferOne(uint _upc) public view returns (
        uint itemSKU,
        uint itemUPC,
        address ownerID
    )
    {
        itemSKU = items[_upc].sku;
        itemUPC = items[_upc].upc;
        ownerID = items[_upc].ownerID;

        return
        (
        itemSKU,
        itemUPC,
        ownerID
        );
    }

    function fetchItemBufferTwo(uint _upc) public view returns
    (
        uint itemSKU,
        uint itemUPC,
        uint productID,
        string memory productNotes,
        uint productPrice,
        uint itemState,
        address consumerID
    )
    {
        itemSKU = items[_upc].sku;
        itemUPC = items[_upc].upc;
        productID = items[_upc].productID;
        productNotes = items[_upc].productNotes;
        productPrice = items[_upc].productPrice;
        itemState = uint(items[_upc].itemState);
        consumerID = items[_upc].consumerID;

        return
        (
        itemSKU,
        itemUPC,
        productID,
        productNotes,
        productPrice,
        itemState,
        consumerID
        );
    }
}
